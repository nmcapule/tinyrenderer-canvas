{"mappings":"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","sources":["<anon>","src/index.ts","src/canvas_wrapper.ts","src/geometry.ts","src/primitives.ts","src/model_loader.ts"],"sourcesContent":["class $33ce7ce44648ae89$export$838423f3adec30fa {\n    constructor(x, y, z){\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromArray(arr) {\n        return new $33ce7ce44648ae89$export$838423f3adec30fa(arr[0], arr[1], arr[2]);\n    }\n    static fromObject({ x: x, y: y, z: z }) {\n        return new $33ce7ce44648ae89$export$838423f3adec30fa(x, y, z);\n    }\n    sub(other) {\n        return new $33ce7ce44648ae89$export$838423f3adec30fa(this.x - other.x, this.y - other.y, this.z - other.z);\n    }\n    dot(other) {\n        return this.x * other.x + this.y * other.y + this.z * other.z;\n    }\n    cross(other) {\n        return new $33ce7ce44648ae89$export$838423f3adec30fa(this.y * other.z - this.z * other.y, this.z * other.x - this.x * other.z, this.x * other.y - this.y * other.x);\n    }\n    unit() {\n        const length = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n        return new $33ce7ce44648ae89$export$838423f3adec30fa(this.x / length, this.y / length, this.z / length);\n    }\n}\nclass $33ce7ce44648ae89$export$ac4bca90992eed1 {\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n        Object.freeze(this);\n    }\n    static fromObject(obj) {\n        return new $33ce7ce44648ae89$export$ac4bca90992eed1(obj.x, obj.y);\n    }\n    sub(other) {\n        return new $33ce7ce44648ae89$export$ac4bca90992eed1(this.x - other.x, this.y - other.y);\n    }\n    swap() {\n        return new $33ce7ce44648ae89$export$ac4bca90992eed1(this.y, this.x);\n    }\n}\nclass $33ce7ce44648ae89$export$892596cec99bc70e {\n    constructor(r, g, b, a){\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n        Object.freeze(this);\n    }\n}\n\n\nfunction $d0ac685262e621dd$export$d1d9ebe1e80d4b4d([p0, p1, p2], p) {\n    const u = (0, $33ce7ce44648ae89$export$838423f3adec30fa).fromArray([\n        p2.x - p0.x,\n        p1.x - p0.x,\n        p0.x - p.x\n    ]).cross((0, $33ce7ce44648ae89$export$838423f3adec30fa).fromArray([\n        p2.y - p0.y,\n        p1.y - p0.y,\n        p0.y - p.y\n    ]));\n    if (Math.abs(u.z) < 1) return (0, $33ce7ce44648ae89$export$838423f3adec30fa).fromArray([\n        -1,\n        1,\n        1\n    ]);\n    return (0, $33ce7ce44648ae89$export$838423f3adec30fa).fromArray([\n        1 - (u.x + u.y) / u.z,\n        u.y / u.z,\n        u.x / u.z\n    ]);\n}\n\n\n\nclass $85b7a4b6766a31db$export$8deced30307fc45d {\n    constructor(canvas){\n        this.canvas = canvas;\n        this.ctx = canvas.getContext(\"2d\");\n        this.resetZBuffer();\n        this.useContextAPI = false;\n        // Make the origin be at the bottom left corner.\n        // this.ctx.transform(1, 0, 0, -1, 0, canvas.height);\n        // Make the origin at the center.\n        this.ctx.transform(1, 0, 0, -1, canvas.width * 0.5, canvas.height * 0.5);\n    }\n    clear() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n    resetZBuffer() {\n        this.zBuffer = Array.from({\n            length: this.canvas.width * this.canvas.height\n        }, ()=>-Infinity);\n    }\n    colorize(color) {\n        if (!color) return \"rgba(0, 0, 0, 0)\";\n        return `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;\n    }\n    drawPixel(p, color) {\n        if (color) this.ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;\n        this.ctx.fillRect(p.x, p.y, 1, 1);\n    }\n    /**\n   * Bresenham's line drawing algorithm.\n   *\n   * Yes, it's easier to just call ctx.lineTo() but this is for learning\n   * purposes. It took me more than 2 hours just to get this right :P It's\n   * not even optimized :))\n   */ drawLine(p0, p1, color) {\n        if (this.useContextAPI) {\n            this.ctx.beginPath();\n            this.ctx.moveTo(p0.x, p0.y);\n            this.ctx.lineTo(p1.x, p1.y);\n            this.ctx.strokeStyle = this.colorize(color);\n            this.ctx.stroke();\n            return;\n        }\n        let steep = false;\n        if (Math.abs(p0.x - p1.x) < Math.abs(p0.y - p1.y)) {\n            steep = true;\n            p0 = p0.swap();\n            p1 = p1.swap();\n        }\n        if (p0.x > p1.x) {\n            const tmp = p0;\n            p0 = p1;\n            p1 = tmp;\n        }\n        const slope = (p1.y - p0.y) / (p1.x - p0.x);\n        for(let x = p0.x; x <= p1.x; x++){\n            const y = p0.y + (x - p0.x) * slope;\n            if (steep) this.drawPixel(new (0, $33ce7ce44648ae89$export$ac4bca90992eed1)(y, x), color);\n            else this.drawPixel(new (0, $33ce7ce44648ae89$export$ac4bca90992eed1)(x, y), color);\n        }\n    }\n    drawTriangle(p0, p1, p2, color) {\n        this.drawLine(p0, p1, color);\n        this.drawLine(p1, p2, color);\n        this.drawLine(p2, p0, color);\n    }\n    drawBarycentricTriangle([p0, p1, p2], color) {\n        const boundingBox = {\n            a: new (0, $33ce7ce44648ae89$export$ac4bca90992eed1)(Math.min(p0.x, p1.x, p2.x), Math.min(p0.y, p1.y, p2.y)),\n            b: new (0, $33ce7ce44648ae89$export$ac4bca90992eed1)(Math.max(p0.x, p1.x, p2.x), Math.max(p0.y, p1.y, p2.y))\n        };\n        for(let px = boundingBox.a.x; px <= boundingBox.b.x; px++)for(let py = boundingBox.a.y; py <= boundingBox.b.y; py++){\n            const bc = (0, $d0ac685262e621dd$export$d1d9ebe1e80d4b4d)([\n                p0,\n                p1,\n                p2\n            ], new (0, $33ce7ce44648ae89$export$ac4bca90992eed1)(px, py));\n            if (bc.x < 0 || bc.y < 0 || bc.z < 0) continue;\n            const pz = p0.z * bc.z + p1.z * bc.x + p2.z * bc.y;\n            const offset = this.canvas.width * this.canvas.height / 2;\n            const idx = Math.floor(px + py * this.canvas.width + offset);\n            if (this.zBuffer[idx] < pz) {\n                this.zBuffer[idx] = pz;\n                this.drawPixel(new (0, $33ce7ce44648ae89$export$ac4bca90992eed1)(px, py), color);\n            }\n        }\n    }\n    /**\n   * The non-useContextAPI path is slow AF, but it also works :))\n   *\n   * Based on ssloy/tinyrenderer lesson #2: Triangle rasterization :D\n   */ drawFilledTriangle(p0, p1, p2, color) {\n        if (this.useContextAPI) {\n            this.ctx.beginPath();\n            this.ctx.moveTo(p0.x, p0.y);\n            this.ctx.lineTo(p1.x, p1.y);\n            this.ctx.lineTo(p2.x, p2.y);\n            this.ctx.closePath();\n            this.ctx.fillStyle = this.colorize(color);\n            this.ctx.fill();\n            return;\n        }\n        const vertices = [\n            p0,\n            p1,\n            p2\n        ];\n        vertices.sort((a, b)=>a.y - b.y);\n        const max = Math.max(vertices[0].y, vertices[1].y, vertices[2].y);\n        for(let y = vertices[0].y; y < max; y++){\n            let base = vertices[0];\n            let second = vertices[1];\n            let third = vertices[2];\n            // Wth... i'm not sure what happened here, but if fucking works.\n            if (y >= vertices[1].y) {\n                base = vertices[2];\n                second = vertices[1];\n                third = vertices[0];\n            }\n            const deltaToBaseY = y - base.y;\n            const percentageProgressLeft = deltaToBaseY / (second.y - base.y);\n            const left = base.x - (base.x - second.x) * percentageProgressLeft;\n            const percentageProgressRight = deltaToBaseY / (third.y - base.y);\n            const right = base.x - (base.x - third.x) * percentageProgressRight;\n            this.drawLine(new (0, $33ce7ce44648ae89$export$ac4bca90992eed1)(left, y), new (0, $33ce7ce44648ae89$export$ac4bca90992eed1)(right, y), color);\n        }\n    }\n}\n\n\n\nasync function $0d2e70a8a047d1ac$export$5cfea46336e7b8ff(url) {\n    const response = await fetch(new URL(url));\n    const payload = await response.text();\n    const model = new $0d2e70a8a047d1ac$export$a1edc412be3e1841([], [], [], []);\n    for (const line of payload.split(\"\\n\")){\n        const parts = line.split(\" \");\n        if (![\n            \"v\",\n            \"vt\",\n            \"vn\",\n            \"f\"\n        ].includes(parts[0])) continue;\n        const t = parts[0];\n        if (t === \"f\") {\n            const v0 = parts[1].split(\"/\").map(parseFloat);\n            const v1 = parts[2].split(\"/\").map(parseFloat);\n            const v2 = parts[3].split(\"/\").map(parseFloat);\n            model.faces.push([\n                v0,\n                v1,\n                v2\n            ]);\n            continue;\n        }\n        const x = parseFloat(parts[1]);\n        const y = parseFloat(parts[2]);\n        const z = parseFloat(parts[3]);\n        if (t === \"v\") model.vertices.push(new (0, $33ce7ce44648ae89$export$838423f3adec30fa)(x, y, z));\n        else if (t === \"vt\") model.textures.push(new (0, $33ce7ce44648ae89$export$838423f3adec30fa)(x, y, z));\n        else if (t === \"vn\") model.normals.push(new (0, $33ce7ce44648ae89$export$838423f3adec30fa)(x, y, z));\n    }\n    return model;\n}\nclass $0d2e70a8a047d1ac$export$a1edc412be3e1841 {\n    constructor(vertices, textures, normals, faces){\n        this.vertices = vertices;\n        this.textures = textures;\n        this.normals = normals;\n        this.faces = faces;\n    }\n    getVerticesForFace(face) {\n        // The reference doc says we are only interested in the first number for\n        // each subarray entry in a face, and that it is one-indexed so we need to\n        // subtract one.\n        // https://github.com/ssloy/tinyrenderer/wiki/Lesson-1:-Bresenham%E2%80%99s-Line-Drawing-Algorithm#wireframe-rendering\n        return face.map((v)=>this.vertices[v[0] - 1]);\n    }\n}\n\n\n\nasync function $b4e14b6b8da86996$var$render(w, models, lightDir = new (0, $33ce7ce44648ae89$export$838423f3adec30fa)(0, 0, -1)) {\n    w.clear();\n    w.resetZBuffer();\n    const start = performance.now();\n    for (const model of models)for (const face of model.faces){\n        const vertices = model.getVerticesForFace(face);\n        const points = vertices.map((v)=>(0, $33ce7ce44648ae89$export$838423f3adec30fa).fromObject({\n                x: v.x * w.canvas.width / 2,\n                y: v.y * w.canvas.height / 2,\n                z: v.z\n            }));\n        const normal = vertices[2].sub(vertices[0]).cross(vertices[1].sub(vertices[0])).unit();\n        const intensity = normal.dot(lightDir);\n        if (intensity < 0) continue;\n        const color = new (0, $33ce7ce44648ae89$export$892596cec99bc70e)(intensity * 255, intensity * 255, intensity * 255, 255);\n        w.drawBarycentricTriangle(points, color);\n    }\n    const end = performance.now();\n    console.log(`Took ${end - start}ms`);\n}\nasync function $b4e14b6b8da86996$var$init() {\n    const canvas = document.getElementById(\"canvas\");\n    if (!canvas.getContext) throw new Error(\"Canvas not supported\");\n    const w = new (0, $85b7a4b6766a31db$export$8deced30307fc45d)(canvas);\n    w.useContextAPI = true;\n    w.clear();\n    const model = await (0, $0d2e70a8a047d1ac$export$5cfea46336e7b8ff)(`${window.location.href}african_head.obj`);\n    canvas.addEventListener(\"mousemove\", (event)=>{\n        const lightDir = new (0, $33ce7ce44648ae89$export$838423f3adec30fa)(-event.x / canvas.height + 0.5, event.y / canvas.height - 0.5, -1);\n        $b4e14b6b8da86996$var$render(w, [\n            model\n        ], lightDir);\n    });\n    function animate(t) {\n        const lightDir = new (0, $33ce7ce44648ae89$export$838423f3adec30fa)(Math.cos(t / 1000) / 4, Math.sin(t / 1000) / 4, -1);\n        $b4e14b6b8da86996$var$render(w, [\n            model\n        ], lightDir);\n        window.requestAnimationFrame(animate);\n    }\n    window.requestAnimationFrame(animate);\n}\n$b4e14b6b8da86996$var$init();\n\n\n//# sourceMappingURL=index.f8a1ebad.js.map\n","import { CanvasWrapper } from \"./canvas_wrapper\";\nimport { Model, loadModel } from \"./model_loader\";\nimport { Vec2, Vec3, Color } from \"./primitives\";\n\nasync function render(\n  w: CanvasWrapper,\n  models: Array<Model>,\n  lightDir: Vec3 = new Vec3(0, 0, -1)\n) {\n  w.clear();\n  w.resetZBuffer();\n  const start = performance.now();\n  for (const model of models) {\n    for (const face of model.faces) {\n      const vertices = model.getVerticesForFace(face);\n      const points = vertices.map((v) =>\n        Vec3.fromObject({\n          x: (v.x * w.canvas.width) / 2,\n          y: (v.y * w.canvas.height) / 2,\n          z: v.z,\n        })\n      );\n\n      const normal = vertices[2]\n        .sub(vertices[0])\n        .cross(vertices[1].sub(vertices[0]))\n        .unit();\n      const intensity = normal.dot(lightDir);\n      if (intensity < 0) {\n        continue;\n      }\n      const color = new Color(\n        intensity * 255,\n        intensity * 255,\n        intensity * 255,\n        255\n      );\n\n      w.drawBarycentricTriangle(points, color);\n    }\n  }\n  const end = performance.now();\n  console.log(`Took ${end - start}ms`);\n}\n\nasync function init() {\n  const canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\n  if (!canvas.getContext) {\n    throw new Error(\"Canvas not supported\");\n  }\n\n  const w = new CanvasWrapper(canvas);\n  w.useContextAPI = true;\n  w.clear();\n\n  const model = await loadModel(`${window.location.href}african_head.obj`);\n\n  canvas.addEventListener(\"mousemove\", (event) => {\n    const lightDir = new Vec3(\n      -event.x / canvas.height + 0.5,\n      event.y / canvas.height - 0.5,\n      -1\n    );\n    render(w, [model], lightDir);\n  });\n\n  function animate(t: number) {\n    const lightDir = new Vec3(\n      Math.cos(t / 1000) / 4,\n      Math.sin(t / 1000) / 4,\n      -1\n    );\n    render(w, [model], lightDir);\n    window.requestAnimationFrame(animate);\n  }\n  window.requestAnimationFrame(animate);\n}\n\ninit();\n","import { barycentric } from \"./geometry\";\nimport { Color, Vec2, Vec3 } from \"./primitives\";\n\nexport class CanvasWrapper {\n  canvas: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n  zBuffer: Array<number>;\n\n  useContextAPI: boolean;\n\n  constructor(canvas: HTMLCanvasElement) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext(\"2d\")!;\n    this.resetZBuffer();\n\n    this.useContextAPI = false;\n\n    // Make the origin be at the bottom left corner.\n    // this.ctx.transform(1, 0, 0, -1, 0, canvas.height);\n\n    // Make the origin at the center.\n    this.ctx.transform(1, 0, 0, -1, canvas.width * 0.5, canvas.height * 0.5);\n  }\n\n  clear() {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  resetZBuffer() {\n    this.zBuffer = Array.from(\n      { length: this.canvas.width * this.canvas.height },\n      () => -Infinity\n    );\n  }\n\n  private colorize(color?: Color) {\n    if (!color) {\n      return \"rgba(0, 0, 0, 0)\";\n    }\n    return `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;\n  }\n\n  drawPixel(p: Vec2, color?: Color) {\n    if (color) {\n      this.ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;\n    }\n    this.ctx.fillRect(p.x, p.y, 1, 1);\n  }\n\n  /**\n   * Bresenham's line drawing algorithm.\n   *\n   * Yes, it's easier to just call ctx.lineTo() but this is for learning\n   * purposes. It took me more than 2 hours just to get this right :P It's\n   * not even optimized :))\n   */\n  drawLine(p0: Vec2, p1: Vec2, color?: Color) {\n    if (this.useContextAPI) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(p0.x, p0.y);\n      this.ctx.lineTo(p1.x, p1.y);\n      this.ctx.strokeStyle = this.colorize(color);\n      this.ctx.stroke();\n      return;\n    }\n\n    let steep = false;\n    if (Math.abs(p0.x - p1.x) < Math.abs(p0.y - p1.y)) {\n      steep = true;\n      p0 = p0.swap();\n      p1 = p1.swap();\n    }\n\n    if (p0.x > p1.x) {\n      const tmp = p0;\n      p0 = p1;\n      p1 = tmp;\n    }\n\n    const slope = (p1.y - p0.y) / (p1.x - p0.x);\n    for (let x = p0.x; x <= p1.x; x++) {\n      const y = p0.y + (x - p0.x) * slope;\n      if (steep) {\n        this.drawPixel(new Vec2(y, x), color);\n      } else {\n        this.drawPixel(new Vec2(x, y), color);\n      }\n    }\n  }\n\n  drawTriangle(p0: Vec2, p1: Vec2, p2: Vec2, color?: Color) {\n    this.drawLine(p0, p1, color);\n    this.drawLine(p1, p2, color);\n    this.drawLine(p2, p0, color);\n  }\n\n  drawBarycentricTriangle([p0, p1, p2]: Array<Vec3>, color?: Color) {\n    const boundingBox = {\n      a: new Vec2(Math.min(p0.x, p1.x, p2.x), Math.min(p0.y, p1.y, p2.y)),\n      b: new Vec2(Math.max(p0.x, p1.x, p2.x), Math.max(p0.y, p1.y, p2.y)),\n    };\n\n    for (let px = boundingBox.a.x; px <= boundingBox.b.x; px++) {\n      for (let py = boundingBox.a.y; py <= boundingBox.b.y; py++) {\n        const bc = barycentric([p0, p1, p2], new Vec2(px, py));\n        if (bc.x < 0 || bc.y < 0 || bc.z < 0) {\n          continue;\n        }\n\n        const pz = p0.z * bc.z + p1.z * bc.x + p2.z * bc.y;\n\n        const offset = (this.canvas.width * this.canvas.height) / 2;\n        const idx = Math.floor(px + py * this.canvas.width + offset);\n\n        if (this.zBuffer[idx] < pz) {\n          this.zBuffer[idx] = pz;\n          this.drawPixel(new Vec2(px, py), color);\n        }\n      }\n    }\n  }\n\n  /**\n   * The non-useContextAPI path is slow AF, but it also works :))\n   *\n   * Based on ssloy/tinyrenderer lesson #2: Triangle rasterization :D\n   */\n  drawFilledTriangle(p0: Vec2, p1: Vec2, p2: Vec2, color?: Color) {\n    if (this.useContextAPI) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(p0.x, p0.y);\n      this.ctx.lineTo(p1.x, p1.y);\n      this.ctx.lineTo(p2.x, p2.y);\n      this.ctx.closePath();\n      this.ctx.fillStyle = this.colorize(color);\n      this.ctx.fill();\n      return;\n    }\n\n    const vertices = [p0, p1, p2];\n    vertices.sort((a, b) => a.y - b.y);\n\n    const max = Math.max(vertices[0].y, vertices[1].y, vertices[2].y);\n    for (let y = vertices[0].y; y < max; y++) {\n      let base = vertices[0];\n      let second = vertices[1];\n      let third = vertices[2];\n\n      // Wth... i'm not sure what happened here, but if fucking works.\n      if (y >= vertices[1].y) {\n        base = vertices[2];\n        second = vertices[1];\n        third = vertices[0];\n      }\n\n      const deltaToBaseY = y - base.y;\n\n      const percentageProgressLeft = deltaToBaseY / (second.y - base.y);\n      const left = base.x - (base.x - second.x) * percentageProgressLeft;\n\n      const percentageProgressRight = deltaToBaseY / (third.y - base.y);\n      const right = base.x - (base.x - third.x) * percentageProgressRight;\n\n      this.drawLine(new Vec2(left, y), new Vec2(right, y), color);\n    }\n  }\n}\n","import { Vec2, Vec3 } from \"./primitives\";\n\n/** I know what barycentric is but this comp is still black magic to me. */\nexport function barycentric([p0, p1, p2]: Array<Vec3 | Vec2>, p: Vec2): Vec3 {\n  const u = Vec3.fromArray([p2.x - p0.x, p1.x - p0.x, p0.x - p.x]).cross(\n    Vec3.fromArray([p2.y - p0.y, p1.y - p0.y, p0.y - p.y])\n  );\n\n  if (Math.abs(u.z) < 1) {\n    return Vec3.fromArray([-1, 1, 1]);\n  }\n\n  return Vec3.fromArray([1 - (u.x + u.y) / u.z, u.y / u.z, u.x / u.z]);\n}\n","export class Vec3 {\n  x: number;\n  y: number;\n  z: number;\n\n  constructor(x: number, y: number, z: number) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  public static fromArray(arr: Array<number>): Vec3 {\n    return new Vec3(arr[0], arr[1], arr[2]);\n  }\n\n  public static fromObject({\n    x,\n    y,\n    z,\n  }: {\n    x: number;\n    y: number;\n    z: number;\n  }): Vec3 {\n    return new Vec3(x, y, z);\n  }\n\n  sub(other: Vec3): Vec3 {\n    return new Vec3(this.x - other.x, this.y - other.y, this.z - other.z);\n  }\n\n  dot(other: Vec3): number {\n    return this.x * other.x + this.y * other.y + this.z * other.z;\n  }\n\n  cross(other: Vec3): Vec3 {\n    return new Vec3(\n      this.y * other.z - this.z * other.y,\n      this.z * other.x - this.x * other.z,\n      this.x * other.y - this.y * other.x\n    );\n  }\n\n  unit(): Vec3 {\n    const length = Math.sqrt(\n      this.x * this.x + this.y * this.y + this.z * this.z\n    );\n    return new Vec3(this.x / length, this.y / length, this.z / length);\n  }\n}\n\nexport class Vec2 {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n    Object.freeze(this);\n  }\n\n  public static fromObject(obj: { x: number; y: number }) {\n    return new Vec2(obj.x, obj.y);\n  }\n\n  sub(other: Vec2): Vec2 {\n    return new Vec2(this.x - other.x, this.y - other.y);\n  }\n\n  swap() {\n    return new Vec2(this.y, this.x);\n  }\n}\n\nexport class Color {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n  constructor(r: number, g: number, b: number, a: number) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n    Object.freeze(this);\n  }\n}\n","import { Vec3 } from \"./primitives\";\n\nexport async function loadModel(url: string): Promise<Model> {\n  const response = await fetch(new URL(url));\n  const payload = await response.text();\n  const model = new Model([], [], [], []);\n\n  for (const line of payload.split(\"\\n\")) {\n    const parts = line.split(\" \");\n    if (![\"v\", \"vt\", \"vn\", \"f\"].includes(parts[0])) {\n      continue;\n    }\n\n    const t = parts[0];\n    if (t === \"f\") {\n      const v0 = parts[1].split(\"/\").map(parseFloat);\n      const v1 = parts[2].split(\"/\").map(parseFloat);\n      const v2 = parts[3].split(\"/\").map(parseFloat);\n      model.faces.push([v0, v1, v2]);\n      continue;\n    }\n\n    const x = parseFloat(parts[1]);\n    const y = parseFloat(parts[2]);\n    const z = parseFloat(parts[3]);\n    if (t === \"v\") {\n      model.vertices.push(new Vec3(x, y, z));\n    } else if (t === \"vt\") {\n      model.textures.push(new Vec3(x, y, z));\n    } else if (t === \"vn\") {\n      model.normals.push(new Vec3(x, y, z));\n    }\n  }\n\n  return model;\n}\n\nexport class Model {\n  vertices: Array<Vec3>;\n  textures: Array<Vec3>;\n  normals: Array<Vec3>;\n  faces: Array<Array<Array<number>>>;\n\n  constructor(\n    vertices: Array<Vec3>,\n    textures: Array<Vec3>,\n    normals: Array<Vec3>,\n    faces: Array<Array<Array<number>>>\n  ) {\n    this.vertices = vertices;\n    this.textures = textures;\n    this.normals = normals;\n    this.faces = faces;\n  }\n\n  getVerticesForFace(face: Array<Array<number>>): Array<Vec3> {\n    // The reference doc says we are only interested in the first number for\n    // each subarray entry in a face, and that it is one-indexed so we need to\n    // subtract one.\n    // https://github.com/ssloy/tinyrenderer/wiki/Lesson-1:-Bresenham%E2%80%99s-Line-Drawing-Algorithm#wireframe-rendering\n    return face.map((v) => this.vertices[v[0] - 1]);\n  }\n}\n"],"names":["$33ce7ce44648ae89$export$838423f3adec30fa","constructor","x","y","z","fromArray","arr","fromObject","sub","other","dot","cross","unit","length","Math","sqrt","$33ce7ce44648ae89$export$ac4bca90992eed1","Object","freeze","obj","swap","$33ce7ce44648ae89$export$892596cec99bc70e","r","g","b","a","$85b7a4b6766a31db$export$8deced30307fc45d","canvas","ctx","getContext","resetZBuffer","useContextAPI","transform","width","height","clear","clearRect","zBuffer","Array","from","Infinity","colorize","color","drawPixel","p","fillStyle","fillRect","drawLine","p0","p1","beginPath","moveTo","lineTo","strokeStyle","stroke","steep","abs","tmp","slope","drawTriangle","p2","drawBarycentricTriangle","boundingBox","min","max","px","py","bc","u","pz","offset","idx","floor","drawFilledTriangle","closePath","fill","vertices","sort","base","second","third","deltaToBaseY","percentageProgressLeft","left","percentageProgressRight","right","$0d2e70a8a047d1ac$export$5cfea46336e7b8ff","url","response","fetch","URL","payload","text","model","$0d2e70a8a047d1ac$export$a1edc412be3e1841","line","split","parts","includes","t","v0","map","parseFloat","v1","v2","faces","push","textures","normals","getVerticesForFace","face","v","$b4e14b6b8da86996$var$render","w","models","lightDir","start","performance","now","points","normal","intensity","end","console","log","$b4e14b6b8da86996$var$init","document","getElementById","Error","window","location","href","addEventListener","event","requestAnimationFrame","animate","cos","sin"],"version":3,"file":"index.f8a1ebad.js.map"}