{"mappings":"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","sources":["<anon>","src/index.ts","src/canvas_wrapper.ts","src/model_loader.ts"],"sourcesContent":["class $85b7a4b6766a31db$export$baf26146a414f24a {\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n        Object.freeze(this);\n    }\n    static fromObject(obj) {\n        return new $85b7a4b6766a31db$export$baf26146a414f24a(obj.x, obj.y);\n    }\n    sub(other) {\n        return new $85b7a4b6766a31db$export$baf26146a414f24a(this.x - other.x, this.y - other.y);\n    }\n    swap() {\n        return new $85b7a4b6766a31db$export$baf26146a414f24a(this.y, this.x);\n    }\n}\nclass $85b7a4b6766a31db$export$ac4bca90992eed1 {\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n        Object.freeze(this);\n    }\n}\nclass $85b7a4b6766a31db$export$892596cec99bc70e {\n    constructor(r, g, b, a){\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n        Object.freeze(this);\n    }\n}\nclass $85b7a4b6766a31db$export$8deced30307fc45d {\n    constructor(canvas){\n        this.canvas = canvas;\n        this.ctx = canvas.getContext(\"2d\");\n        this.useContextAPI = false;\n        // Make the origin be at the bottom left corner.\n        // this.ctx.transform(1, 0, 0, -1, 0, canvas.height);\n        // Make the origin at the center.\n        this.ctx.transform(1, 0, 0, -1, canvas.width * 0.5, canvas.height * 0.5);\n    }\n    clear() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n    colorize(color) {\n        if (!color) return \"rgba(0, 0, 0, 0)\";\n        return `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;\n    }\n    drawPixel(p, color) {\n        if (color) this.ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;\n        this.ctx.fillRect(p.x, p.y, 1, 1);\n    }\n    /**\n   * Bresenham's line drawing algorithm.\n   *\n   * Yes, it's easier to just call ctx.lineTo() but this is for learning\n   * purposes. It took me more than 2 hours just to get this right :P It's\n   * not even optimized :))\n   */ drawLine(p0, p1, color) {\n        if (this.useContextAPI) {\n            this.ctx.beginPath();\n            this.ctx.moveTo(p0.x, p0.y);\n            this.ctx.lineTo(p1.x, p1.y);\n            this.ctx.strokeStyle = this.colorize(color);\n            this.ctx.stroke();\n            return;\n        }\n        let steep = false;\n        if (Math.abs(p0.x - p1.x) < Math.abs(p0.y - p1.y)) {\n            steep = true;\n            p0 = p0.swap();\n            p1 = p1.swap();\n        }\n        if (p0.x > p1.x) {\n            const tmp = p0;\n            p0 = p1;\n            p1 = tmp;\n        }\n        const slope = (p1.y - p0.y) / (p1.x - p0.x);\n        for(let x = p0.x; x <= p1.x; x++){\n            const y = p0.y + (x - p0.x) * slope;\n            if (steep) this.drawPixel(new $85b7a4b6766a31db$export$baf26146a414f24a(y, x), color);\n            else this.drawPixel(new $85b7a4b6766a31db$export$baf26146a414f24a(x, y), color);\n        }\n    }\n    drawTriangle(p0, p1, p2, color) {\n        this.drawLine(p0, p1, color);\n        this.drawLine(p1, p2, color);\n        this.drawLine(p2, p0, color);\n    }\n    /**\n   * The non-useContextAPI path is slow AF, but it also works :))\n   *\n   * Based on ssloy/tinyrenderer lesson #2: Triangle rasterization :D\n   */ drawFilledTriangle(p0, p1, p2, color) {\n        if (this.useContextAPI) {\n            this.ctx.beginPath();\n            this.ctx.moveTo(p0.x, p0.y);\n            this.ctx.lineTo(p1.x, p1.y);\n            this.ctx.lineTo(p2.x, p2.y);\n            this.ctx.closePath();\n            this.ctx.fillStyle = this.colorize(color);\n            this.ctx.fill();\n            return;\n        }\n        const vertices = [\n            p0,\n            p1,\n            p2\n        ];\n        vertices.sort((a, b)=>a.y - b.y);\n        const max = Math.max(vertices[0].y, vertices[1].y, vertices[2].y);\n        for(let y = vertices[0].y; y < max; y++){\n            let base = vertices[0];\n            let second = vertices[1];\n            let third = vertices[2];\n            // Wth... i'm not sure what happened here, but if fucking works.\n            if (y >= vertices[1].y) {\n                base = vertices[2];\n                second = vertices[1];\n                third = vertices[0];\n            }\n            const deltaToBaseY = y - base.y;\n            const percentageProgressLeft = deltaToBaseY / (second.y - base.y);\n            const left = base.x - (base.x - second.x) * percentageProgressLeft;\n            const percentageProgressRight = deltaToBaseY / (third.y - base.y);\n            const right = base.x - (base.x - third.x) * percentageProgressRight;\n            this.drawLine(new $85b7a4b6766a31db$export$baf26146a414f24a(left, y), new $85b7a4b6766a31db$export$baf26146a414f24a(right, y), color);\n        }\n    }\n}\n\n\nclass $0d2e70a8a047d1ac$export$838423f3adec30fa {\n    constructor(x, y, z){\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromArray(arr) {\n        return new $0d2e70a8a047d1ac$export$838423f3adec30fa(arr[0], arr[1], arr[2]);\n    }\n}\nasync function $0d2e70a8a047d1ac$export$5cfea46336e7b8ff(url) {\n    const response = await fetch(new URL(url));\n    const payload = await response.text();\n    const model = new $0d2e70a8a047d1ac$export$a1edc412be3e1841([], [], [], []);\n    for (const line of payload.split(\"\\n\")){\n        const parts = line.split(\" \");\n        if (![\n            \"v\",\n            \"vt\",\n            \"vn\",\n            \"f\"\n        ].includes(parts[0])) continue;\n        const t = parts[0];\n        if (t === \"f\") {\n            const v0 = parts[1].split(\"/\").map(parseFloat);\n            const v1 = parts[2].split(\"/\").map(parseFloat);\n            const v2 = parts[3].split(\"/\").map(parseFloat);\n            model.faces.push([\n                v0,\n                v1,\n                v2\n            ]);\n            continue;\n        }\n        const x = parseFloat(parts[1]);\n        const y = parseFloat(parts[2]);\n        const z = parseFloat(parts[3]);\n        if (t === \"v\") model.vertices.push(new $0d2e70a8a047d1ac$export$838423f3adec30fa(x, y, z));\n        else if (t === \"vt\") model.textures.push(new $0d2e70a8a047d1ac$export$838423f3adec30fa(x, y, z));\n        else if (t === \"vn\") model.normals.push(new $0d2e70a8a047d1ac$export$838423f3adec30fa(x, y, z));\n    }\n    return model;\n}\nclass $0d2e70a8a047d1ac$export$a1edc412be3e1841 {\n    constructor(vertices, textures, normals, faces){\n        this.vertices = vertices;\n        this.textures = textures;\n        this.normals = normals;\n        this.faces = faces;\n    }\n    getVerticesForFace(face) {\n        // The reference doc says we are only interested in the first number for\n        // each subarray entry in a face, and that it is one-indexed so we need to\n        // subtract one.\n        // https://github.com/ssloy/tinyrenderer/wiki/Lesson-1:-Bresenham%E2%80%99s-Line-Drawing-Algorithm#wireframe-rendering\n        return face.map((v)=>this.vertices[v[0] - 1]);\n    }\n}\n\n\nasync function $b4e14b6b8da86996$var$render(w) {\n    const model = await (0, $0d2e70a8a047d1ac$export$5cfea46336e7b8ff)(`${window.location.href}african_head.obj`);\n    const start = performance.now();\n    for(let i = 0; i < model.faces.length; i++){\n        const vertices = model.getVerticesForFace(model.faces[i]);\n        const points = vertices.map((v)=>(0, $85b7a4b6766a31db$export$baf26146a414f24a).fromObject({\n                x: v.x * w.canvas.width / 2,\n                y: v.y * w.canvas.height / 2\n            }));\n        w.drawFilledTriangle(points[0], points[1], points[2], new (0, $85b7a4b6766a31db$export$892596cec99bc70e)(Math.random() * 255, Math.random() * 255, Math.random() * 255, 255));\n    }\n    const end = performance.now();\n    console.log(`Took ${end - start}ms`);\n}\nconst $b4e14b6b8da86996$var$canvas = document.getElementById(\"canvas\");\nif (!$b4e14b6b8da86996$var$canvas.getContext) throw new Error(\"Canvas not supported\");\nconst $b4e14b6b8da86996$var$w = new (0, $85b7a4b6766a31db$export$8deced30307fc45d)($b4e14b6b8da86996$var$canvas);\n$b4e14b6b8da86996$var$w.useContextAPI = true;\n$b4e14b6b8da86996$var$w.clear();\n// Add hook to the render button.\nconst $b4e14b6b8da86996$var$renderButton = document.getElementById(\"render\");\n$b4e14b6b8da86996$var$renderButton.addEventListener(\"click\", ()=>$b4e14b6b8da86996$var$render($b4e14b6b8da86996$var$w));\n// But.. let's render at start anyways.\n$b4e14b6b8da86996$var$render($b4e14b6b8da86996$var$w);\n\n\n//# sourceMappingURL=index.9d00823a.js.map\n","import { CanvasWrapper, Point, Color } from \"./canvas_wrapper\";\nimport { loadModel } from \"./model_loader\";\n\nasync function render(w: CanvasWrapper) {\n  const model = await loadModel(`${window.location.href}african_head.obj`);\n\n  const start = performance.now();\n  for (let i = 0; i < model.faces.length; i++) {\n    const vertices = model.getVerticesForFace(model.faces[i]);\n    const points = vertices.map((v) =>\n      Point.fromObject({\n        x: (v.x * w.canvas.width) / 2,\n        y: (v.y * w.canvas.height) / 2,\n      })\n    );\n    w.drawFilledTriangle(\n      points[0],\n      points[1],\n      points[2],\n      new Color(\n        Math.random() * 255,\n        Math.random() * 255,\n        Math.random() * 255,\n        255\n      )\n    );\n  }\n  const end = performance.now();\n  console.log(`Took ${end - start}ms`);\n}\n\nconst canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\nif (!canvas.getContext) {\n  throw new Error(\"Canvas not supported\");\n}\n\nconst w = new CanvasWrapper(canvas);\nw.useContextAPI = true;\nw.clear();\n\n// Add hook to the render button.\nconst renderButton = document.getElementById(\"render\")! as HTMLButtonElement;\nrenderButton.addEventListener(\"click\", () => render(w));\n\n// But.. let's render at start anyways.\nrender(w);\n","export class Point {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n    Object.freeze(this);\n  }\n\n  public static fromObject(obj: { x: number; y: number }) {\n    return new Point(obj.x, obj.y);\n  }\n\n  sub(other: Point): Point {\n    return new Point(this.x - other.x, this.y - other.y);\n  }\n\n  swap() {\n    return new Point(this.y, this.x);\n  }\n}\n\nexport class Vec2 {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n    Object.freeze(this);\n  }\n}\n\nexport class Color {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n  constructor(r: number, g: number, b: number, a: number) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n    Object.freeze(this);\n  }\n}\n\nexport class CanvasWrapper {\n  canvas: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n\n  useContextAPI: boolean;\n\n  constructor(canvas: HTMLCanvasElement) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext(\"2d\")!;\n\n    this.useContextAPI = false;\n\n    // Make the origin be at the bottom left corner.\n    // this.ctx.transform(1, 0, 0, -1, 0, canvas.height);\n\n    // Make the origin at the center.\n    this.ctx.transform(1, 0, 0, -1, canvas.width * 0.5, canvas.height * 0.5);\n  }\n\n  clear() {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  private colorize(color?: Color) {\n    if (!color) {\n      return \"rgba(0, 0, 0, 0)\";\n    }\n    return `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;\n  }\n\n  drawPixel(p: Point, color?: Color) {\n    if (color) {\n      this.ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;\n    }\n    this.ctx.fillRect(p.x, p.y, 1, 1);\n  }\n\n  /**\n   * Bresenham's line drawing algorithm.\n   *\n   * Yes, it's easier to just call ctx.lineTo() but this is for learning\n   * purposes. It took me more than 2 hours just to get this right :P It's\n   * not even optimized :))\n   */\n  drawLine(p0: Point, p1: Point, color?: Color) {\n    if (this.useContextAPI) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(p0.x, p0.y);\n      this.ctx.lineTo(p1.x, p1.y);\n      this.ctx.strokeStyle = this.colorize(color);\n      this.ctx.stroke();\n      return;\n    }\n\n    let steep = false;\n    if (Math.abs(p0.x - p1.x) < Math.abs(p0.y - p1.y)) {\n      steep = true;\n      p0 = p0.swap();\n      p1 = p1.swap();\n    }\n\n    if (p0.x > p1.x) {\n      const tmp = p0;\n      p0 = p1;\n      p1 = tmp;\n    }\n\n    const slope = (p1.y - p0.y) / (p1.x - p0.x);\n    for (let x = p0.x; x <= p1.x; x++) {\n      const y = p0.y + (x - p0.x) * slope;\n      if (steep) {\n        this.drawPixel(new Point(y, x), color);\n      } else {\n        this.drawPixel(new Point(x, y), color);\n      }\n    }\n  }\n\n  drawTriangle(p0: Point, p1: Point, p2: Point, color?: Color) {\n    this.drawLine(p0, p1, color);\n    this.drawLine(p1, p2, color);\n    this.drawLine(p2, p0, color);\n  }\n\n  /**\n   * The non-useContextAPI path is slow AF, but it also works :))\n   *\n   * Based on ssloy/tinyrenderer lesson #2: Triangle rasterization :D\n   */\n  drawFilledTriangle(p0: Point, p1: Point, p2: Point, color?: Color) {\n    if (this.useContextAPI) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(p0.x, p0.y);\n      this.ctx.lineTo(p1.x, p1.y);\n      this.ctx.lineTo(p2.x, p2.y);\n      this.ctx.closePath();\n      this.ctx.fillStyle = this.colorize(color);\n      this.ctx.fill();\n      return;\n    }\n\n    const vertices = [p0, p1, p2];\n    vertices.sort((a, b) => a.y - b.y);\n\n    const max = Math.max(vertices[0].y, vertices[1].y, vertices[2].y);\n    for (let y = vertices[0].y; y < max; y++) {\n      let base = vertices[0];\n      let second = vertices[1];\n      let third = vertices[2];\n\n      // Wth... i'm not sure what happened here, but if fucking works.\n      if (y >= vertices[1].y) {\n        base = vertices[2];\n        second = vertices[1];\n        third = vertices[0];\n      }\n\n      const deltaToBaseY = y - base.y;\n\n      const percentageProgressLeft = deltaToBaseY / (second.y - base.y);\n      const left = base.x - (base.x - second.x) * percentageProgressLeft;\n\n      const percentageProgressRight = deltaToBaseY / (third.y - base.y);\n      const right = base.x - (base.x - third.x) * percentageProgressRight;\n\n      this.drawLine(new Point(left, y), new Point(right, y), color);\n    }\n  }\n}\n","export class Vec3 {\n  x: number;\n  y: number;\n  z: number;\n\n  constructor(x: number, y: number, z: number) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  public static fromArray(arr: Array<number>): Vec3 {\n    return new Vec3(arr[0], arr[1], arr[2]);\n  }\n}\n\nexport async function loadModel(url: string): Promise<Model> {\n  const response = await fetch(new URL(url));\n  const payload = await response.text();\n  const model = new Model([], [], [], []);\n\n  for (const line of payload.split(\"\\n\")) {\n    const parts = line.split(\" \");\n    if (![\"v\", \"vt\", \"vn\", \"f\"].includes(parts[0])) {\n      continue;\n    }\n\n    const t = parts[0];\n    if (t === \"f\") {\n      const v0 = parts[1].split(\"/\").map(parseFloat);\n      const v1 = parts[2].split(\"/\").map(parseFloat);\n      const v2 = parts[3].split(\"/\").map(parseFloat);\n      model.faces.push([v0, v1, v2]);\n      continue;\n    }\n\n    const x = parseFloat(parts[1]);\n    const y = parseFloat(parts[2]);\n    const z = parseFloat(parts[3]);\n    if (t === \"v\") {\n      model.vertices.push(new Vec3(x, y, z));\n    } else if (t === \"vt\") {\n      model.textures.push(new Vec3(x, y, z));\n    } else if (t === \"vn\") {\n      model.normals.push(new Vec3(x, y, z));\n    }\n  }\n\n  return model;\n}\n\nexport class Model {\n  vertices: Array<Vec3>;\n  textures: Array<Vec3>;\n  normals: Array<Vec3>;\n  faces: Array<Array<Array<number>>>;\n\n  constructor(\n    vertices: Array<Vec3>,\n    textures: Array<Vec3>,\n    normals: Array<Vec3>,\n    faces: Array<Array<Array<number>>>\n  ) {\n    this.vertices = vertices;\n    this.textures = textures;\n    this.normals = normals;\n    this.faces = faces;\n  }\n\n  getVerticesForFace(face: Array<Array<number>>): Array<Vec3> {\n    // The reference doc says we are only interested in the first number for\n    // each subarray entry in a face, and that it is one-indexed so we need to\n    // subtract one.\n    // https://github.com/ssloy/tinyrenderer/wiki/Lesson-1:-Bresenham%E2%80%99s-Line-Drawing-Algorithm#wireframe-rendering\n    return face.map((v) => this.vertices[v[0] - 1]);\n  }\n}\n"],"names":["$85b7a4b6766a31db$export$baf26146a414f24a","constructor","x","y","Object","freeze","fromObject","obj","sub","other","swap","$85b7a4b6766a31db$export$892596cec99bc70e","r","g","b","a","$0d2e70a8a047d1ac$export$838423f3adec30fa","z","fromArray","arr","$0d2e70a8a047d1ac$export$5cfea46336e7b8ff","url","response","fetch","URL","payload","text","model","$0d2e70a8a047d1ac$export$a1edc412be3e1841","line","split","parts","includes","t","v0","map","parseFloat","v1","v2","faces","push","vertices","textures","normals","getVerticesForFace","face","v","$b4e14b6b8da86996$var$render","w","window","location","href","start","performance","now","i","length","points","canvas","width","height","drawFilledTriangle","Math","random","end","console","log","$b4e14b6b8da86996$var$canvas","document","getElementById","getContext","Error","$b4e14b6b8da86996$var$w","ctx","useContextAPI","transform","clear","clearRect","colorize","color","drawPixel","p","fillStyle","fillRect","drawLine","p0","p1","beginPath","moveTo","lineTo","strokeStyle","stroke","steep","abs","tmp","slope","drawTriangle","p2","closePath","fill","sort","max","base","second","third","deltaToBaseY","percentageProgressLeft","left","percentageProgressRight","right","$b4e14b6b8da86996$var$renderButton","addEventListener"],"version":3,"file":"index.9d00823a.js.map"}